/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "./environments";
import * as core from "./core";
import { VellumApi } from "@fern-api/vellum";
import urlJoin from "url-join";
import * as serializers from "./serialization";
import * as errors from "./errors";

export declare namespace VellumApiClient {
    interface Options {
        environment: environments.VellumApiEnvironment | string;
        apiKey?: core.Supplier<string>;
    }
}

export class VellumApiClient {
    constructor(private readonly options: VellumApiClient.Options) {}

    /**
     * <strong style="background-color:#4caf50; color:white; padding:4px; border-radius:4px">Stable</strong>
     *
     * Generate a completion using a previously defined deployment.
     *
     * **Note:** Uses a base url of `https://predict.vellum.ai`.
     */
    public async generate(request: VellumApi.GenerateRequestBodyRequest): Promise<VellumApi.GenerateResponse> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, "/v1/generate"),
            method: "POST",
            headers: {
                X_API_KEY: await core.Supplier.get(this.options.apiKey),
            },
            body: await serializers.GenerateRequestBodyRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.GenerateResponse.parseOrThrow(_response.body as serializers.GenerateResponse.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VellumApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VellumApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.VellumApiTimeoutError();
            case "unknown":
                throw new errors.VellumApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     * <strong style="background-color:#ffc107; color:white; padding:4px; border-radius:4px">Unstable</strong>
     *
     * Used to retrieve a model version given its ID.
     *
     */
    public async retrieveModelVersions(id: string): Promise<VellumApi.ModelVersionRead> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, `/v1/model-versions/${id}`),
            method: "GET",
            headers: {
                X_API_KEY: await core.Supplier.get(this.options.apiKey),
            },
        });
        if (_response.ok) {
            return await serializers.ModelVersionRead.parseOrThrow(_response.body as serializers.ModelVersionRead.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VellumApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VellumApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.VellumApiTimeoutError();
            case "unknown":
                throw new errors.VellumApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * <strong style="background-color:#4caf50; color:white; padding:4px; border-radius:4px">Stable</strong>
     *
     * Perform a search against a document index.
     *
     * **Note:** Uses a base url of `https://predict.vellum.ai`.
     */
    public async search(request: VellumApi.SearchRequestBodyRequest): Promise<VellumApi.SearchResponse> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, "/v1/search"),
            method: "POST",
            headers: {
                X_API_KEY: await core.Supplier.get(this.options.apiKey),
            },
            body: await serializers.SearchRequestBodyRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.SearchResponse.parseOrThrow(_response.body as serializers.SearchResponse.Raw, {
                allowUnknownKeys: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VellumApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VellumApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.VellumApiTimeoutError();
            case "unknown":
                throw new errors.VellumApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * <strong style="background-color:#4caf50; color:white; padding:4px; border-radius:4px">Stable</strong>
     *
     * Used to submit feedback regarding the quality of previously generated completions.
     *
     * **Note:** Uses a base url of `https://predict.vellum.ai`.
     */
    public async submitCompletionActuals(request: VellumApi.SubmitCompletionActualsRequestRequest): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, "/v1/submit-completion-actuals"),
            method: "POST",
            headers: {
                X_API_KEY: await core.Supplier.get(this.options.apiKey),
            },
            body: await serializers.SubmitCompletionActualsRequestRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VellumApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VellumApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.VellumApiTimeoutError();
            case "unknown":
                throw new errors.VellumApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * <strong style="background-color:#4caf50; color:white; padding:4px; border-radius:4px">Stable</strong>
     *
     * Upload a document to be indexed and used for search.
     *
     * **Note:** Uses a base url of `https://documents.vellum.ai`.
     */
    public async uploadDocument(request: VellumApi.UploadDocumentRequestBodyRequest): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, "/v1/upload-document"),
            method: "POST",
            headers: {
                X_API_KEY: await core.Supplier.get(this.options.apiKey),
            },
            body: await serializers.UploadDocumentRequestBodyRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VellumApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VellumApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.VellumApiTimeoutError();
            case "unknown":
                throw new errors.VellumApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
